/**
 * @file router/index.ts
 * @description Manages application routing and rendering of components based on the current path.
 * Defines route paths and their corresponding components, and provides functions to handle routing logic and rendering.
 * @note This code is taken from a boiler-plate created by Monde Sineke.
 * @author Your Name
 */

import FeedPage from '../pages/FeedPage';
import ProfilePage from '../pages/ProfilePage';
import NotFoundPage from '../pages/NotFoundPage';
import { lazyLoadImgs } from '../utils/lazy-load-img';
import { APP_CONTAINER_CLASSNAME } from '../constant';
import LoginPage from '../pages/LogInPage';
import RegisterPage from '../pages/RegisterPage';
import { isLoggedIn } from '../utils/auth';

const PATHS = {
  login: {
    url: '/',
    component: LoginPage,
  },
  feed: {
    url: '/feed',
    component: FeedPage,
    protected: true,
  },
  profile: {
    url: '/profile',
    component: ProfilePage,
    protected: true,
  },
  register: {
    url: '/register',
    component: RegisterPage,
  },
} as const;

/**
 * Handles routing logic for the application by matching the current path to a route definition.
 *
 * @param currentPath - The current URL path to match against the route definitions.
 * @param routes - An object containing route definitions, where each route has a `url` and a `component`.
 * @returns The HTML string generated by the matched route's component, or the NotFoundPage if no match is found.
 */
export default async function router(
  currentPath = '',
  routes = PATHS
): Promise<string> {
  // Find the matching route by path
  const currentRoute = Object.values(routes).find(
    (route) => route.url === currentPath
  );

  let html = await NotFoundPage();

  if (currentRoute) {
    // Check if route is protected and user is not logged in
    if ((currentRoute as any).protected && !isLoggedIn()) {
      // Redirect to login page
      history.pushState({ path: '/' }, '', '/');
      html = await LoginPage();
    } else if (currentPath === '/' && isLoggedIn()) {
      // If user is logged in and tries to access login page, redirect to feed
      history.pushState({ path: '/feed' }, '', '/feed');
      html = await FeedPage();
    } else {
      html = await currentRoute.component();
    }
  }

  return html;
}

/**
 * Renders the content for a given route path by updating the main content container.
 *
 * @param path - The optional route path to render. If not provided, uses the current window location pathname.
 * @returns A promise that resolves when the route content has been rendered and any post-render logic has executed.
 *
 * @remarks
 * - Updates the inner HTML of the main application container with the result of the router function.
 * - Executes any post-render logic (e.g., lazy loading images) after the content is rendered.
 * - If the path or content container is not available, the function exits early.
 */
export async function renderRoute(path?: string | undefined) {
  path = path ?? window.location.pathname;

  // Get the element where content will be rendered
  const contentContainer = document.getElementById(APP_CONTAINER_CLASSNAME);

  if (!path || !contentContainer) return;

  // Show loading screen for login and register pages
  const loadingScreen = (window as any).loadingScreen;
  if (loadingScreen && (path === '/login' || path === '/register')) {
    loadingScreen.showWithMessage(
      path === '/login' ? 'Loading Sign In...' : 'Loading Registration...'
    );

    // Add a small delay for better UX
    await new Promise((resolve) => setTimeout(resolve, 1000));
  }

  const html = await router(path);

  contentContainer.innerHTML = html;

  // Hide loading screen after content is rendered
  if (loadingScreen && (path === '/login' || path === '/register')) {
    setTimeout(() => {
      loadingScreen.hideLoadingScreen();
    }, 500);
  }

  // Run any code that needs DOM elements here after route render;
  lazyLoadImgs();
}
